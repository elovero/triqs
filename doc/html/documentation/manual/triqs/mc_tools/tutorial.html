
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Tutorial &#8212; TRIQS Docs</title>
    <link rel="stylesheet" href="../../../../_static/triqs2.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../../../_static/triqs2.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=default"></script>
    <link rel="author" title="About these documents" href="../../../../about.html" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
  <link rel="stylesheet" href="https://use.typekit.net/hsv6sot.css">
  <script type="text/javascript">try{Typekit.load();}catch(e){}</script>

  </head>
<body class="layout">

  <header class="header">
    <nav class="header-content">
      <div class="row header-row">
        <div class="col-xs-2 logo-col">
          <div class="row start-xs">
            <div class="nav-item">
              <a class="nav-link" href="/"
                ><span class="nav-logo">TRIQS</span></a
              >
            </div>
          </div>
        </div>
        <div class="col-xs-6">
          <div class="row">
            <div class="nav-item">
              <a class="nav-link" href="/documentation.html">Docs</a>
            </div>
            <div class="nav-item">
              <a class="nav-link" href="/tutorials.html">Tutorials</a>
            </div>
            <div class="nav-item">
              <a class="nav-link" href="/applications.html">Applications</a>
            </div>
            <div class="nav-item">
              <a class="nav-link" href="/community.html">Community</a>
            </div>
          </div>
        </div>
        <div class="col-xs-4">
          <div class="row end-xs">
            <div class="nav-item">
              <a class="nav-link" href="/about.html">About</a>
            </div>
            <div class="nav-item">
              <a class="nav-link" target="_blank" rel="noopener noreferrer" href="https://github.com/TRIQS/triqs">Github</a>
            </div>
          </div>
        </div>
      </div>
    </nav>
  </header>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="tutorial">
<h1>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h1>
<p>In order to have a first overview of the main features of the <code class="docutils literal notranslate"><span class="pre">mc_generic</span></code>
class, let’s start with a concrete Monte Carlo code. We will consider maybe the
simplest problem ever: a single spin in a magnetic field <span class="math notranslate nohighlight">\(h\)</span> at a
temperature <span class="math notranslate nohighlight">\(1/\beta\)</span>. The Hamiltonian is simply:</p>
<div class="math notranslate nohighlight">
\[\mathcal{H} = - h (n_\uparrow - n_\downarrow).\]</div>
<p>You want to compute the magnetization of this single spin. From statistical
mechanics it is clearly just</p>
<div class="math notranslate nohighlight">
\[m = \frac{\exp(\beta h) - \exp(-\beta h)}{\exp(\beta h) + \exp(-\beta h)}\]</div>
<div class="section" id="the-c-code-for-this-problem">
<h2>The C++ code for this problem<a class="headerlink" href="#the-c-code-for-this-problem" title="Permalink to this headline">¶</a></h2>
<p>Let’s see how we can get this result from a Monte Carlo simulation. Here is
a code that would do the job. Note that we put everything in one file here,
but obviously you would usually want to cut this into pieces for clarity:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;triqs/utility/callbacks.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;triqs/mc_tools/mc_generic.hpp&gt;</span><span class="cp"></span>

<span class="c1">// --------------- the configuration: a spin, the inverse temperature, the external field ---</span>
<span class="k">struct</span> <span class="n">configuration</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">spin</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">beta</span><span class="p">,</span> <span class="n">h</span><span class="p">;</span>
  <span class="n">configuration</span><span class="p">(</span><span class="kt">double</span> <span class="n">beta_</span><span class="p">,</span> <span class="kt">double</span> <span class="n">h_</span><span class="p">)</span> <span class="o">:</span> <span class="n">spin</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">beta</span><span class="p">(</span><span class="n">beta_</span><span class="p">),</span> <span class="n">h</span><span class="p">(</span><span class="n">h_</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">// --------------- a move: flip the spin ---------------</span>
<span class="k">struct</span> <span class="n">flip</span> <span class="p">{</span>
  <span class="n">configuration</span> <span class="o">*</span><span class="n">config</span><span class="p">;</span>

  <span class="n">flip</span><span class="p">(</span><span class="n">configuration</span> <span class="o">*</span><span class="n">config_</span><span class="p">)</span> <span class="o">:</span> <span class="n">config</span><span class="p">(</span><span class="n">config_</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">double</span> <span class="n">attempt</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">spin</span> <span class="o">*</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">h</span> <span class="o">*</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">beta</span><span class="p">);</span> <span class="p">}</span>
  <span class="kt">double</span> <span class="n">accept</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">config</span><span class="o">-&gt;</span><span class="n">spin</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mf">1.0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">reject</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">//  ----------------- a measurement: the magnetization ------------</span>
<span class="k">struct</span> <span class="n">compute_m</span> <span class="p">{</span>
  <span class="n">configuration</span> <span class="o">*</span><span class="n">config</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">compute_m</span><span class="p">(</span><span class="n">configuration</span> <span class="o">*</span><span class="n">config_</span><span class="p">)</span> <span class="o">:</span> <span class="n">config</span><span class="p">(</span><span class="n">config_</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">void</span> <span class="n">accumulate</span><span class="p">(</span><span class="kt">double</span> <span class="n">sign</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Z</span> <span class="o">+=</span> <span class="n">sign</span><span class="p">;</span>
    <span class="n">M</span> <span class="o">+=</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">spin</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">collect_results</span><span class="p">(</span><span class="n">mpi</span><span class="o">::</span><span class="n">communicator</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">sum_Z</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">::</span><span class="n">reduce</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">sum_M</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">::</span><span class="n">reduce</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">rank</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Magnetization: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">sum_M</span> <span class="o">/</span> <span class="n">sum_Z</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">//  ----------------- main ------------</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>

  <span class="c1">// initialize mpi</span>
  <span class="n">mpi</span><span class="o">::</span><span class="n">environment</span> <span class="n">env</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
  <span class="n">mpi</span><span class="o">::</span><span class="n">communicator</span> <span class="n">world</span><span class="p">;</span>

  <span class="c1">// greeting</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">world</span><span class="p">.</span><span class="n">rank</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Isolated spin&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="c1">// prepare the MC parameters</span>
  <span class="kt">int</span> <span class="n">n_cycles</span>            <span class="o">=</span> <span class="mi">5000000</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">length_cycle</span>        <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">n_warmup_cycles</span>     <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">random_name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">random_seed</span>         <span class="o">=</span> <span class="mi">374982</span> <span class="o">+</span> <span class="n">world</span><span class="p">.</span><span class="n">rank</span><span class="p">()</span> <span class="o">*</span> <span class="mi">273894</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">verbosity</span>           <span class="o">=</span> <span class="p">(</span><span class="n">world</span><span class="p">.</span><span class="n">rank</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

  <span class="c1">// construct a Monte Carlo loop</span>
  <span class="n">triqs</span><span class="o">::</span><span class="n">mc_tools</span><span class="o">::</span><span class="n">mc_generic</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">SpinMC</span><span class="p">(</span><span class="n">random_name</span><span class="p">,</span> <span class="n">random_seed</span><span class="p">,</span> <span class="n">verbosity</span><span class="p">);</span>

  <span class="c1">// parameters of the model</span>
  <span class="kt">double</span> <span class="n">beta</span>  <span class="o">=</span> <span class="mf">0.3</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">field</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>

  <span class="c1">// construct configuration</span>
  <span class="n">configuration</span> <span class="n">config</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">field</span><span class="p">);</span>

  <span class="c1">// add moves and measures</span>
  <span class="n">SpinMC</span><span class="p">.</span><span class="n">add_move</span><span class="p">(</span><span class="n">flip</span><span class="p">(</span><span class="o">&amp;</span><span class="n">config</span><span class="p">),</span> <span class="s">&quot;flip move&quot;</span><span class="p">);</span>
  <span class="n">SpinMC</span><span class="p">.</span><span class="n">add_measure</span><span class="p">(</span><span class="n">compute_m</span><span class="p">(</span><span class="o">&amp;</span><span class="n">config</span><span class="p">),</span> <span class="s">&quot;magnetization measure&quot;</span><span class="p">);</span>

  <span class="c1">// Run and collect results</span>
  <span class="n">SpinMC</span><span class="p">.</span><span class="n">warmup_and_accumulate</span><span class="p">(</span><span class="n">n_warmup_cycles</span><span class="p">,</span> <span class="n">n_cycles</span><span class="p">,</span> <span class="n">length_cycle</span><span class="p">,</span> <span class="n">triqs</span><span class="o">::</span><span class="n">utility</span><span class="o">::</span><span class="n">clock_callback</span><span class="p">(</span><span class="mi">600</span><span class="p">));</span>

  <span class="n">SpinMC</span><span class="p">.</span><span class="n">collect_results</span><span class="p">(</span><span class="n">world</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Let’s go through the different parts of this code. First we look
at <code class="docutils literal notranslate"><span class="pre">main()</span></code>.</p>
</div>
<div class="section" id="initializing-the-mpi">
<h2>Initializing the MPI<a class="headerlink" href="#initializing-the-mpi" title="Permalink to this headline">¶</a></h2>
<p>As you will see, the Monte Carlo class is completely MPI ready.  The first two
lines of the <code class="docutils literal notranslate"><span class="pre">main()</span></code> just initialize the MPI environment and declare a
communicator. The default communicator is <code class="docutils literal notranslate"><span class="pre">WORLD</span></code> which means that all the
nodes will be involved in the calculation:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">triqs</span><span class="o">::</span><span class="n">mpi</span><span class="o">::</span><span class="n">environment</span> <span class="n">env</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
<span class="n">triqs</span><span class="o">::</span><span class="n">mpi</span><span class="o">::</span><span class="n">communicator</span> <span class="n">world</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="constructing-the-monte-carlo-simulation">
<h2>Constructing the Monte Carlo simulation<a class="headerlink" href="#constructing-the-monte-carlo-simulation" title="Permalink to this headline">¶</a></h2>
<p>The lines that follow, define the parameters of the Monte
Carlo simulation and construct a Monte Carlo object
called <code class="docutils literal notranslate"><span class="pre">SpinMC</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">n_cycles</span> <span class="o">=</span> <span class="mi">5000000</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">length_cycle</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n_warmup_cycles</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">random_name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">random_seed</span> <span class="o">=</span> <span class="mi">374982</span> <span class="o">+</span> <span class="n">world</span><span class="p">.</span><span class="n">rank</span><span class="p">()</span> <span class="o">*</span> <span class="mi">273894</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">verbosity</span> <span class="o">=</span> <span class="p">(</span><span class="n">world</span><span class="p">.</span><span class="n">rank</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">2</span><span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

<span class="n">triqs</span><span class="o">::</span><span class="n">mc_tools</span><span class="o">::</span><span class="n">mc_generic</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">SpinMC</span><span class="p">(</span><span class="n">random_name</span><span class="p">,</span> <span class="n">random_seed</span><span class="p">,</span> <span class="n">initial_sign</span><span class="p">,</span> <span class="n">verbosity</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">SpinMC</span></code> is an instance of the <code class="docutils literal notranslate"><span class="pre">mc_generic</span></code> class. First of all, note
that you need to include the header <code class="docutils literal notranslate"><span class="pre">&lt;triqs/mc_tools/mc_generic.hpp&gt;</span></code> in
order to access the <code class="docutils literal notranslate"><span class="pre">mc_generic</span></code> class. The <code class="docutils literal notranslate"><span class="pre">mc_generic</span></code> class is a
template on the type of the Monte Carlo sign. Usually this will be either a
<code class="docutils literal notranslate"><span class="pre">double</span></code> or a <code class="docutils literal notranslate"><span class="pre">complex&lt;double&gt;</span></code>.</p>
<p>The first two arguments define the random number generator by giving its name in
<code class="docutils literal notranslate"><span class="pre">random_name</span></code> (an empty string means the default generator, i.e. the Mersenne
Twister) and the random seed in <code class="docutils literal notranslate"><span class="pre">random_seed</span></code>. As you see the seed is
different for all node with the use of <code class="docutils literal notranslate"><span class="pre">world.rank()</span></code>.</p>
<p>The third argument is the sign of the very first <em>configuration</em> of the
simulation. Because the <code class="docutils literal notranslate"><span class="pre">accept</span></code> method only returns a ratio, this initial
sign is used to determine the sign of all generated configurations.</p>
<p>Finally, the last parameter sets the verbosity level. 0 means no output, 1 will
output the progress level for the current node and 2 additionally shows some
statistics about the simulation when you call <code class="docutils literal notranslate"><span class="pre">collect_results</span></code>. As you see,
we have put <code class="docutils literal notranslate"><span class="pre">verbosity</span></code> to 2 only for the master node and 0 for all the other
ones. This way the information will be printed only by the master.</p>
</div>
<div class="section" id="moves-and-measures">
<h2>Moves and measures<a class="headerlink" href="#moves-and-measures" title="Permalink to this headline">¶</a></h2>
<p>At this stage the basic structure of the Monte Carlo is in <code class="docutils literal notranslate"><span class="pre">SpinMC</span></code>. But we
now need to tell it what moves must be tried and what measures must be made.
This is done with:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>
  <span class="c1">// Run and collect results</span>
</pre></div>
</div>
<p>The method <code class="docutils literal notranslate"><span class="pre">add_move</span></code> expects a move and a name, while
<code class="docutils literal notranslate"><span class="pre">add_measure</span></code> expects a measure and a name. The name can be
anything, but different measures must have different names. In this example,
the move is an instance of the <code class="docutils literal notranslate"><span class="pre">flip</span></code> class and the measure an instance of
the <code class="docutils literal notranslate"><span class="pre">compute_m</span></code> class. These classes have been defined in the beginning of
the code and they have no direct connection with the <code class="docutils literal notranslate"><span class="pre">mc_generic</span></code> class (e.g.
they don’t have inheritance links with <code class="docutils literal notranslate"><span class="pre">mc_generic</span></code>).  Actually you are
almost completely free to design these classes as you want, <strong>as long as they
satisfy the correct concept</strong>.</p>
</div>
<div class="section" id="the-move">
<h2>The move<a class="headerlink" href="#the-move" title="Permalink to this headline">¶</a></h2>
<p>Let’s go back to the beginning of the code and have a look at the <code class="docutils literal notranslate"><span class="pre">flip</span></code>
class which proposed a flip of the spin. The class is very short.  It has a
constructor which might define some class variables. But more importantly, it
has three member functions that any move <strong>must</strong> have: <code class="docutils literal notranslate"><span class="pre">attempt</span></code>, <code class="docutils literal notranslate"><span class="pre">accept</span></code> and
<code class="docutils literal notranslate"><span class="pre">reject</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>  <span class="n">configuration</span> <span class="o">*</span><span class="n">config</span><span class="p">;</span>

  <span class="n">flip</span><span class="p">(</span><span class="n">configuration</span> <span class="o">*</span><span class="n">config_</span><span class="p">)</span> <span class="o">:</span> <span class="n">config</span><span class="p">(</span><span class="n">config_</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">double</span> <span class="n">attempt</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">spin</span> <span class="o">*</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">h</span> <span class="o">*</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">beta</span><span class="p">);</span> <span class="p">}</span>
  <span class="kt">double</span> <span class="n">accept</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">config</span><span class="o">-&gt;</span><span class="n">spin</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mf">1.0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">reject</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">attempt</span></code> method is called by the Monte Carlo loop in order to try a new
move. The Monte Carlo class doesn’t care about what this trial is. All that
matters for the loop is the Metropolis ratio describing the transition to a new
proposed configuration. It is precisely this ratio that the <code class="docutils literal notranslate"><span class="pre">attempt</span></code> method is
expected to return:</p>
<div class="math notranslate nohighlight">
\[T = \frac{P_{y,x} \rho(y)}{P_{x,y}\rho(x)}\]</div>
<p>In our example this ratio is</p>
<div class="math notranslate nohighlight">
\[T = \frac{e^{\beta h -\sigma }}{e^{\beta h \sigma}} = e^{ - 2 \beta h \sigma }\]</div>
<p>With this ratio, the Monte Carlo loop decides whether this proposed move should
be rejected, or accepted. If the move is accepted, the Monte Carlo calls the
<code class="docutils literal notranslate"><span class="pre">accept</span></code> method of the move, otherwise it calls the <code class="docutils literal notranslate"><span class="pre">reject</span></code> method.  The
<code class="docutils literal notranslate"><span class="pre">accept</span></code> method should always return 1.0 unless you want to correct the sign
only when moves are accepted for performance reasons (this rather special case
is described in the <a class="reference internal" href="concepts.html#montecarloref"><span class="std std-ref">full documentation/manual/triqs</span></a>).  Note that the
return type of <code class="docutils literal notranslate"><span class="pre">attempt</span></code> and <code class="docutils literal notranslate"><span class="pre">accept</span></code> has to be the same as the template of the
Monte Carlo class.  In our example, nothing has to be done if the move is
rejected. If it is accepted, the spin should be flipped.</p>
</div>
<div class="section" id="the-measure">
<h2>The measure<a class="headerlink" href="#the-measure" title="Permalink to this headline">¶</a></h2>
<p>Just in the same way, the measures are expected to satisfy a concept.
Let’s look at <code class="docutils literal notranslate"><span class="pre">compute_m</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>  <span class="n">configuration</span> <span class="o">*</span><span class="n">config</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">Z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">compute_m</span><span class="p">(</span><span class="n">configuration</span> <span class="o">*</span><span class="n">config_</span><span class="p">)</span> <span class="o">:</span> <span class="n">config</span><span class="p">(</span><span class="n">config_</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">void</span> <span class="n">accumulate</span><span class="p">(</span><span class="kt">double</span> <span class="n">sign</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Z</span> <span class="o">+=</span> <span class="n">sign</span><span class="p">;</span>
    <span class="n">M</span> <span class="o">+=</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">spin</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">collect_results</span><span class="p">(</span><span class="n">mpi</span><span class="o">::</span><span class="n">communicator</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">sum_Z</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">::</span><span class="n">reduce</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">sum_M</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">::</span><span class="n">reduce</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">rank</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Magnetization: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">sum_M</span> <span class="o">/</span> <span class="n">sum_Z</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">//  ----------------- main ------------</span>
</pre></div>
</div>
<p>Here only two methods are expected, <code class="docutils literal notranslate"><span class="pre">accumulate</span></code> and <code class="docutils literal notranslate"><span class="pre">collect_results</span></code>.
The method <code class="docutils literal notranslate"><span class="pre">accumulate</span></code> is called every <code class="docutils literal notranslate"><span class="pre">length_cycle</span></code> Monte Carlo loops.
It takes one argument which is the current sign in the Monte Carlo simulation.
Here, we sum the sign in <code class="docutils literal notranslate"><span class="pre">Z</span></code> (the partition function) and the magnetization
in <code class="docutils literal notranslate"><span class="pre">M</span></code>. The other method <code class="docutils literal notranslate"><span class="pre">collect_results</span></code> is usually called just once at
the very end of the simulation, see below. It is meant to do the final
operations that are needed to have your result. Here it just needs to divide
<code class="docutils literal notranslate"><span class="pre">M</span></code> by <code class="docutils literal notranslate"><span class="pre">Z</span></code> and prints the result on the screen. Note that, it takes the MPI
communicator as an argument, meaning that you can easily do MPI operations
here.  This makes sense because the accumulation will have taken place
independently on all nodes and this is the good moment to gather the
information from all the nodes. This is why you see reduce operations on the
master node here.</p>
</div>
<div class="section" id="starting-the-monte-carlo-simulation">
<h2>Starting the Monte Carlo simulation<a class="headerlink" href="#starting-the-monte-carlo-simulation" title="Permalink to this headline">¶</a></h2>
<p>Well, at this stage we’re ready to launch our simulation. The moves
and measures have been specified, so all you need to do now is start
the simulation with:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SpinMC</span><span class="p">.</span><span class="n">warmup_and_accumulate</span><span class="p">(</span><span class="n">n_warmup_cycles</span><span class="p">,</span> <span class="n">n_cycles</span><span class="p">,</span> <span class="n">length_cycle</span><span class="p">,</span> <span class="n">triqs</span><span class="o">::</span><span class="n">utility</span><span class="o">::</span><span class="n">clock_callback</span><span class="p">(</span><span class="mi">600</span><span class="p">));</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">warmup</span></code> method takes several arguments.</p>
<p>The first three parameters determine the warmup length, number of measurements
and the length of the Monte Carlo cycles.  The definition of these variables
has been detailed earlier in <a class="reference internal" href="loop.html#montecarloloop"><span class="std std-ref">Introduction</span></a>.</p>
<p>The last argument is used to decide if the simulation must be stopped for some
reason before it reaches the full number of cycles <code class="docutils literal notranslate"><span class="pre">n_cycles</span></code>. For example,
you might be running your code on a cluster that only allows for 1 hour
simulations. In that case, you would want your simulation to stop, say after 55
minutes, even if it didn’t manage to do the <code class="docutils literal notranslate"><span class="pre">n_cycles</span></code> cycles.</p>
<p>In practice, the second argument is a <code class="docutils literal notranslate"><span class="pre">std::function&lt;bool</span> <span class="pre">()&gt;</span></code> which is
called at the end of every cycle. If it returns 0 the simulation goes on, if it
returns 1 the simulation stops. In this example, we used a function
<code class="docutils literal notranslate"><span class="pre">clock_callback(600)</span></code> which starts returning 1 after 600 seconds.  It is
defined in the header <code class="file docutils literal notranslate"><span class="pre">&lt;triqs/utility/callbacks.hpp&gt;</span></code>.  This way the
simulation will last at most 10 minutes.</p>
<p>Note that the simulation would end cleanly. The rest of the code can safely
gather results from the statistics that has been accumulated, even if there
have been less than <code class="docutils literal notranslate"><span class="pre">n_cycles</span></code> cycles.</p>
</div>
<div class="section" id="end-of-the-simulation-gathering-results">
<h2>End of the simulation - gathering results<a class="headerlink" href="#end-of-the-simulation-gathering-results" title="Permalink to this headline">¶</a></h2>
<p>When the simulation is over, it is time to gather the results.  This is done by
calling:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SpinMC</span><span class="p">.</span><span class="n">collect_results</span><span class="p">(</span><span class="n">world</span><span class="p">);</span>
</pre></div>
</div>
<p>In practice this method goes through all the measurements that have been added
to the simulation and calls their <code class="docutils literal notranslate"><span class="pre">collect_results</span></code> member. As described
above, this does the final computations needed to get the result you are
interested in. It usually also saves or prints these results.</p>
</div>
<div class="section" id="writing-your-own-monte-carlo-simulation">
<h2>Writing your own Monte Carlo simulation<a class="headerlink" href="#writing-your-own-monte-carlo-simulation" title="Permalink to this headline">¶</a></h2>
<p>I hope that this simple example gave you an idea about how to use the
<code class="docutils literal notranslate"><span class="pre">mc_generic</span></code> class. In the next chapter we will address some more advanced
issues, but you should already be able to implement a Monte Carlo simulation of
your own. Maybe the only point that we haven’t addressed and which is useful,
is how to generate random numbers. Actually, as soon as you have generated an
instance of a <code class="docutils literal notranslate"><span class="pre">mc_generic</span></code> class, like <code class="docutils literal notranslate"><span class="pre">SpinMC</span></code> above, you automatically
have an acces to a random number generator with:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">triqs</span><span class="o">::</span><span class="n">mc_tools</span><span class="o">::</span><span class="n">random_generator</span> <span class="n">RNG</span> <span class="o">=</span> <span class="n">SpinMC</span><span class="p">.</span><span class="n">get_rng</span><span class="p">();</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">RNG</span></code> is an instance of a <code class="docutils literal notranslate"><span class="pre">random_generator</span></code>. If you want to
generate a <code class="docutils literal notranslate"><span class="pre">double</span></code> number on the interval <span class="math notranslate nohighlight">\([0,1[\)</span>, you just have to
call <code class="docutils literal notranslate"><span class="pre">RNG()</span></code>. By providing an argument to <code class="docutils literal notranslate"><span class="pre">RNG</span></code> you can generate integer
and real numbers on different intervals. This is described in detail in the
section <a class="reference internal" href="random.html#random"><span class="std std-ref">Random number generator</span></a>.</p>
<p>That’s it! Why don’t you try to write your own Monte Carlo describing an
<span class="xref std std-ref">Ising chain in a field</span>? You will find the solution
in <a class="reference internal" href="ising.html#ising-solution"><span class="std std-ref">this section</span></a>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="sidebar">
  <div class="container-fluid sidebar-container">
      <div class="row sidebar-row">
        <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../gettingstarted.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mainconcepts.html">Main Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../applications.html">Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../capiref.html">C++ API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pythonapiref.html">Python API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faqs.html">FAQS</a></li>
</ul>

      </div>
      <div class="row sidebar-row search-row">
        <div
          class="sidebar-section"
          id="searchbox"
          style="display: none"
          role="search"
        >
          <div class="sidebar-header">
            <a class="sidebar-header-link">Quick search</a>
          </div>
        </div>
        <div class="searchformwrapper">
          <form class="search" action="../../../../search.html" method="get">
            <input type="text" name="q" aria-labelledby="searchlabel" />
            <input type="submit" value="Go" />
          </form>
        </div>
        <script type="text/javascript">
          $("#searchbox").show(0);
        </script>
      </div>
    </div>
  </div>
</div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <footer>
    <div class="container-fluid">
      <div class="row footer">
        <div class="col-xs-12 center-xs middle-xs">
          <div class="outro">
            <p class="footer-description">
              TRIQS (Toolbox for Research on Interacting Quantum Systems) is a
              scientific project providing a set of C++ and Python libraries to
              develop new tools for the study of interacting quantum systems based
              at the Center for Computational Quantum Physics at the Flatiron
              Institute.
            </p>
          </div>
          <ul class="footer-links">
            <li class="footer-link">
              <a exact="true" href="/about.html">About</a>
            </li>
            <li class="footer-link">
              <a
                target="_blank"
                rel="noopener noreferrer"
                href="https://simonsfoundation.org"
                >Simons Foundation</a
              >
            </li>
            <li class="footer-link">
              <a
                target="_blank"
                rel="noopener noreferrer"
                href="https://flatironinstitute.org"
                >Flatiron Institute</a
              >
            </li>
            <li class="footer-link"><a exact="true" href="/">Github</a></li>
            <li class="footer-link"><a exact="true" href="/contact">Contact</a></li>
          </ul>
          <p class="updated">Updated on November 20, 2019 (2:20pm)</p>
        </div>
      </div>
    </div>
  </footer>

  </body>
</html>